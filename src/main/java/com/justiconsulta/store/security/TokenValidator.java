package com.justiconsulta.store.security;

import com.nimbusds.jose.jwk.JWK;
import com.nimbusds.jose.jwk.JWKSet;
import com.nimbusds.jose.jwk.RSAKey;
import com.nimbusds.jose.jwk.ECKey;
import com.nimbusds.jose.crypto.RSASSAVerifier;
import com.nimbusds.jose.crypto.ECDSAVerifier;
import com.nimbusds.jose.crypto.MACVerifier;
import com.nimbusds.jwt.SignedJWT;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.nio.charset.StandardCharsets;
import java.text.ParseException;
import java.time.Instant;
import java.util.Base64;
import java.util.List;
import java.util.Map;

@Component
public class TokenValidator {
    private static final Logger logger = LoggerFactory.getLogger(TokenValidator.class);

    private final JwkService jwkService;
    private final String expectedIssuer; // e.g. https://<supabase>.supabase.co/auth/v1
    private final byte[] hmacSecretBytes; // for HS* tokens generated by Supabase / local JwtTokenService
    private final byte[] hmacSecretBytesB64; // optional: base64-decoded secret if applicable

    public TokenValidator(JwkService jwkService,
                          @Value("${supabase.url}") String supabaseUrl,
                          @Value("${security.jwt.secret:}") String jwtSecret) {
        this.jwkService = jwkService;
        if (supabaseUrl.endsWith("/")) {
            this.expectedIssuer = supabaseUrl + "auth/v1";
        } else {
            this.expectedIssuer = supabaseUrl + "/auth/v1";
        }
        String cleaned = (jwtSecret == null) ? "" : jwtSecret.trim();
        if ((cleaned.startsWith("\"") && cleaned.endsWith("\"")) || (cleaned.startsWith("'") && cleaned.endsWith("'"))) {
            cleaned = cleaned.substring(1, cleaned.length() - 1);
        }
        this.hmacSecretBytes = cleaned.isEmpty() ? new byte[0] : cleaned.getBytes(StandardCharsets.UTF_8);
        byte[] decoded = new byte[0];
        if (!cleaned.isEmpty()) {
            try {
                decoded = Base64.getDecoder().decode(cleaned);
            } catch (IllegalArgumentException ignored) {
                // not base64
            }
        }
        this.hmacSecretBytesB64 = decoded;
        if (supabaseUrl == null || supabaseUrl.isBlank()) {
            logger.warn("supabase.url is empty. If the token contains an issuer (iss), validation may fail. Configure SUPABASE_URL environment variable.");
        }
    }

    public TokenValidationResult validate(String token) {
        if (token == null || token.isBlank()) return TokenValidationResult.invalid();
        try {
            SignedJWT jwt = SignedJWT.parse(token);

            String alg = jwt.getHeader().getAlgorithm() != null ? jwt.getHeader().getAlgorithm().getName() : "(null)";
            String kid = jwt.getHeader().getKeyID();
            logger.debug("Validating JWT header alg={} kid={}", alg, kid);

            boolean verified = false;
            // HS* (HMAC) tokens: verify only with local secret. JWKS does NOT apply for HS algorithms.
            if (alg != null && alg.startsWith("HS")) {
                if (hmacSecretBytes.length == 0) {
                    logger.warn("HS* token received but no HMAC secret configured. Set security.jwt.secret (env JWT_SECRET_KEY from Supabase 'JWT Secret').");
                    return TokenValidationResult.invalid();
                }
                try {
                    MACVerifier macVerifier = new MACVerifier(hmacSecretBytes);
                    verified = jwt.verify(macVerifier);
                    if (!verified && hmacSecretBytesB64.length > 0) {
                        logger.warn("HMAC verification with plain secret failed, retrying with Base64-decoded secret fallback.");
                        MACVerifier macVerifierB64 = new MACVerifier(hmacSecretBytesB64);
                        verified = jwt.verify(macVerifierB64);
                    }
                    if (!verified) {
                        logger.warn("HMAC verification failed for HS token. Likely an incorrect JWT secret. Ensure security.jwt.secret matches Supabase JWT Secret (not anon/service keys). If you pasted a Base64 value, keep it as-is; fallback was attempted.");
                        return TokenValidationResult.invalid();
                    }
                } catch (Exception e) {
                    logger.warn("HMAC verification threw an error for HS token", e);
                    return TokenValidationResult.invalid();
                }
            } else {
                // RS*/EC* tokens: verify against JWKS
                try {
                    verified = verifyWithJwkSet(jwt, false);
                } catch (Exception e) {
                    logger.warn("Error verifying JWT with JWK set", e);
                    verified = false;
                }
                if (!verified) {
                    try {
                        verified = verifyWithJwkSet(jwt, true);
                    } catch (Exception e) {
                        logger.warn("Error verifying JWT with refreshed JWK set", e);
                        verified = false;
                    }
                }
            }

            if (!verified) {
                logger.warn("JWT verification failed for token");
                return TokenValidationResult.invalid();
            }

            // validate claims: exp, nbf
            Instant now = Instant.now();
            if (jwt.getJWTClaimsSet().getExpirationTime() == null || jwt.getJWTClaimsSet().getExpirationTime().toInstant().isBefore(now)) {
                logger.warn("JWT expired");
                return TokenValidationResult.invalid();
            }
            if (jwt.getJWTClaimsSet().getNotBeforeTime() != null && jwt.getJWTClaimsSet().getNotBeforeTime().toInstant().isAfter(now)) {
                logger.warn("JWT not valid yet (nbf)");
                return TokenValidationResult.invalid();
            }

            // validate issuer only if present in token
            String iss = jwt.getJWTClaimsSet().getIssuer();
            if (iss != null && !iss.isBlank()) {
                // Only enforce issuer match if expectedIssuer is configured (non-blank)
                if (expectedIssuer != null && !expectedIssuer.isBlank()) {
                    if (!iss.equalsIgnoreCase(expectedIssuer)) {
                        logger.warn("Unexpected issuer: {} expected: {}", iss, expectedIssuer);
                        return TokenValidationResult.invalid();
                    }
                } else {
                    logger.warn("Token contains issuer {} but expectedIssuer is not configured (supabase.url missing). Skipping issuer validation.", iss);
                }
            }

            // extract principal: prefer claim "document_number", then "email", then subject
            Map<String, Object> claims = jwt.getJWTClaimsSet().getClaims();
            String principal = null;
            if (claims.containsKey("document_number")) {
                Object v = claims.get("document_number");
                if (v != null) principal = v.toString();
            }
            if (principal == null && claims.containsKey("email")) {
                Object v = claims.get("email");
                if (v != null) principal = v.toString();
            }
            if (principal == null) {
                String sub = jwt.getJWTClaimsSet().getSubject();
                if (sub != null) principal = sub;
            }

            List<String> authorities = List.of();
            return new TokenValidationResult(true, principal, authorities);

        } catch (ParseException ex) {
            logger.warn("Failed to parse JWT", ex);
            return TokenValidationResult.invalid();
        } catch (Exception ex) {
            logger.error("Unexpected error validating token", ex);
            return TokenValidationResult.invalid();
        }
    }

    private boolean verifyWithJwkSet(SignedJWT jwt, boolean forceRefresh) throws Exception {
        JWKSet jwkSet = jwkService.getJwkSet(forceRefresh);
        String kid = jwt.getHeader().getKeyID();
        JWK jwk = null;
        if (kid != null) jwk = jwkSet.getKeyByKeyId(kid);
        if (jwk == null) {
            // fallback: try any key that matches algorithm
            for (JWK k : jwkSet.getKeys()) {
                if (k.getAlgorithm() == null) continue;
                if (k.getAlgorithm().equals(jwt.getHeader().getAlgorithm())) {
                    jwk = k; break;
                }
            }
        }
        if (jwk == null) {
            logger.debug("No JWK matched by kid/alg; attempting to verify with all RSA/EC keys as fallback");
            // Try verifying with each RSA/EC key in the set (fallback when kid is missing)
            for (JWK k : jwkSet.getKeys()) {
                try {
                    if (k instanceof RSAKey rsaKey) {
                        RSASSAVerifier verifier = new RSASSAVerifier(rsaKey.toRSAPublicKey());
                        if (jwt.verify(verifier)) return true;
                    } else if (k instanceof ECKey ecKey) {
                        ECDSAVerifier verifier = new ECDSAVerifier(ecKey.toECPublicKey());
                        if (jwt.verify(verifier)) return true;
                    }
                } catch (Exception e) {
                    // ignore and try next key
                }
            }
            logger.warn("No matching JWK found for token header kid={} and alg={} after exhaustive check", kid, jwt.getHeader().getAlgorithm());
            return false;
        }

        try {
            if (jwk instanceof RSAKey rsaKey) {
                RSASSAVerifier verifier = new RSASSAVerifier(rsaKey.toRSAPublicKey());
                return jwt.verify(verifier);
            } else if (jwk instanceof ECKey ecKey) {
                ECDSAVerifier verifier = new ECDSAVerifier(ecKey.toECPublicKey());
                return jwt.verify(verifier);
            } else {
                logger.warn("Unsupported JWK type: {}", jwk.getClass());
                return false;
            }
        } catch (Exception e) {
            logger.warn("Signature verification failed, will try refresh if not forced", e);
            if (!forceRefresh) {

                return false;
            }
            return false;
        }
    }
}
