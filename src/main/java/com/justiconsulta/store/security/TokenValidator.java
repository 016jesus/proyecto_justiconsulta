package com.justiconsulta.store.security;

import com.nimbusds.jose.jwk.JWK;
import com.nimbusds.jose.jwk.JWKSet;
import com.nimbusds.jose.jwk.RSAKey;
import com.nimbusds.jose.jwk.ECKey;
import com.nimbusds.jose.crypto.RSASSAVerifier;
import com.nimbusds.jose.crypto.ECDSAVerifier;
import com.nimbusds.jose.crypto.MACVerifier;
import com.nimbusds.jwt.SignedJWT;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.text.ParseException;
import java.time.Instant;
import java.util.List;
import java.util.Map;

@Component
public class TokenValidator {
    private static final Logger logger = LoggerFactory.getLogger(TokenValidator.class);

    private final JwkService jwkService;
    private final String expectedIssuer; // e.g. https://<supabase>.supabase.co/auth/v1
    private final byte[] hmacSecretBytes; // for HS* tokens generated by our JwtTokenService

    public TokenValidator(JwkService jwkService,
                          @Value("${supabase.url}") String supabaseUrl,
                          @Value("${security.jwt.secret:}") String jwtSecret) {
        this.jwkService = jwkService;
        if (supabaseUrl.endsWith("/")) {
            this.expectedIssuer = supabaseUrl + "auth/v1";
        } else {
            this.expectedIssuer = supabaseUrl + "/auth/v1";
        }
        this.hmacSecretBytes = (jwtSecret == null) ? new byte[0] : jwtSecret.getBytes();
    }

    public TokenValidationResult validate(String token) {
        if (token == null || token.isBlank()) return TokenValidationResult.invalid();
        try {
            SignedJWT jwt = SignedJWT.parse(token);

            String alg = jwt.getHeader().getAlgorithm() != null ? jwt.getHeader().getAlgorithm().getName() : "(null)";
            String kid = jwt.getHeader().getKeyID();
            logger.debug("Validating JWT header alg={} kid={}", alg, kid);

            boolean verified = false;
            // If HMAC algorithm (HS*), try MAC verification with our local secret
            if (alg != null && alg.startsWith("HS")) {
                if (hmacSecretBytes.length == 0) {
                    logger.warn("No local HMAC secret configured but token uses HS algo");
                    // Fallthrough: continue to try JWKS as last resort
                } else {
                    try {
                        MACVerifier macVerifier = new MACVerifier(hmacSecretBytes);
                        verified = jwt.verify(macVerifier);
                    } catch (Exception e) {
                        logger.warn("HMAC verification failed for HS token", e);
                        verified = false;
                    }
                }
            }

            if (!verified) {
                // Try verification with JWKS (for RS/EC keys)
                try {
                    verified = verifyWithJwkSet(jwt, false);
                } catch (Exception e) {
                    logger.warn("Error verifying JWT with JWK set", e);
                    verified = false;
                }
                if (!verified) {
                    // try refreshing JWKs once
                    try {
                        verified = verifyWithJwkSet(jwt, true);
                    } catch (Exception e) {
                        logger.warn("Error verifying JWT with refreshed JWK set", e);
                        verified = false;
                    }
                }
            }

            // If still not verified and we have an HMAC secret, try MAC verification as fallback
            if (!verified && hmacSecretBytes.length > 0) {
                try {
                    MACVerifier macVerifier = new MACVerifier(hmacSecretBytes);
                    if (jwt.verify(macVerifier)) {
                        logger.debug("Token verified with local HMAC secret as fallback");
                        verified = true;
                    }
                } catch (Exception e) {
                    // ignore
                }
            }

            if (!verified) {
                logger.warn("JWT verification failed for token");
                return TokenValidationResult.invalid();
            }

            // validate claims: exp, nbf
            Instant now = Instant.now();
            if (jwt.getJWTClaimsSet().getExpirationTime() == null || jwt.getJWTClaimsSet().getExpirationTime().toInstant().isBefore(now)) {
                logger.warn("JWT expired");
                return TokenValidationResult.invalid();
            }
            if (jwt.getJWTClaimsSet().getNotBeforeTime() != null && jwt.getJWTClaimsSet().getNotBeforeTime().toInstant().isAfter(now)) {
                logger.warn("JWT not valid yet (nbf)");
                return TokenValidationResult.invalid();
            }

            // validate issuer only if present in token
            String iss = jwt.getJWTClaimsSet().getIssuer();
            if (iss != null && !iss.isBlank()) {
                if (!iss.equalsIgnoreCase(expectedIssuer)) {
                    logger.warn("Unexpected issuer: {} expected: {}", iss, expectedIssuer);
                    return TokenValidationResult.invalid();
                }
            }

            // extract principal: prefer claim "document_number", then "email", then subject
            Map<String, Object> claims = jwt.getJWTClaimsSet().getClaims();
            String principal = null;
            if (claims.containsKey("document_number")) {
                Object v = claims.get("document_number");
                if (v != null) principal = v.toString();
            }
            if (principal == null && claims.containsKey("email")) {
                Object v = claims.get("email");
                if (v != null) principal = v.toString();
            }
            if (principal == null) {
                String sub = jwt.getJWTClaimsSet().getSubject();
                if (sub != null) principal = sub;
            }

            List<String> authorities = List.of();
            return new TokenValidationResult(true, principal, authorities);

        } catch (ParseException ex) {
            logger.warn("Failed to parse JWT", ex);
            return TokenValidationResult.invalid();
        } catch (Exception ex) {
            logger.error("Unexpected error validating token", ex);
            return TokenValidationResult.invalid();
        }
    }

    private boolean verifyWithJwkSet(SignedJWT jwt, boolean forceRefresh) throws Exception {
        JWKSet jwkSet = jwkService.getJwkSet(forceRefresh);
        String kid = jwt.getHeader().getKeyID();
        JWK jwk = null;
        if (kid != null) jwk = jwkSet.getKeyByKeyId(kid);
        if (jwk == null) {
            // fallback: try any key that matches algorithm
            for (JWK k : jwkSet.getKeys()) {
                if (k.getAlgorithm() == null) continue;
                if (k.getAlgorithm().equals(jwt.getHeader().getAlgorithm())) {
                    jwk = k; break;
                }
            }
        }
        if (jwk == null) {
            logger.debug("No JWK matched by kid/alg; attempting to verify with all RSA/EC keys as fallback");
            // Try verifying with each RSA/EC key in the set (fallback when kid is missing)
            for (JWK k : jwkSet.getKeys()) {
                try {
                    if (k instanceof RSAKey rsaKey) {
                        RSASSAVerifier verifier = new RSASSAVerifier(rsaKey.toRSAPublicKey());
                        if (jwt.verify(verifier)) return true;
                    } else if (k instanceof ECKey ecKey) {
                        ECDSAVerifier verifier = new ECDSAVerifier(ecKey.toECPublicKey());
                        if (jwt.verify(verifier)) return true;
                    }
                } catch (Exception e) {
                    // ignore and try next key
                }
            }
            logger.warn("No matching JWK found for token header kid={} and alg={} after exhaustive check", kid, jwt.getHeader().getAlgorithm());
            return false;
        }

        try {
            if (jwk instanceof RSAKey rsaKey) {
                RSASSAVerifier verifier = new RSASSAVerifier(rsaKey.toRSAPublicKey());
                return jwt.verify(verifier);
            } else if (jwk instanceof ECKey ecKey) {
                ECDSAVerifier verifier = new ECDSAVerifier(ecKey.toECPublicKey());
                return jwt.verify(verifier);
            } else {
                logger.warn("Unsupported JWK type: {}", jwk.getClass());
                return false;
            }
        } catch (Exception e) {
            logger.warn("Signature verification failed, will try refresh if not forced", e);
            if (!forceRefresh) {

                return false;
            }
            return false;
        }
    }
}
